using System;
using System.Collections.Generic;
using CSBL.Reporting;
using CSBL.Transformation;
using CSBL.Interpretation.Functions;
using CSBL.Interpretation.Operators;

namespace CSBL.Interpretation
{
    /// <summary>
    /// This class is responsible for taking a list of transformed tokens and interpreting
    /// them. The interpreter also stores an environment which is managed and changed by
    /// the input code.
    /// </summary>
    public class Interpreter
    {
        public List<TransformedToken> InputTokens { get; private set; }
        public Dictionary<string, FunctionBase> Functions { get; private set; }
        public Dictionary<string, OperatorBase> Operators { get; private set; }
        public InterpreterEnvironment Environment { get; private set; }

        /// <summary>
        /// Constructor for the Interpreter class.
        /// </summary>
        /// <param name="inputTokens">The input tokens generated by the transformer.</param>
        /// <param name="functions">The default functions within CSBL.</param>
        /// <param name="operators">The default operators within CSBL.</param>
        public Interpreter(List<TransformedToken> inputTokens, Dictionary<string, FunctionBase> functions, Dictionary<string, OperatorBase> operators)
        {
            this.InputTokens = inputTokens;
            this.Functions = functions;
            this.Operators = operators;
            this.Environment = new InterpreterEnvironment();
        }

        public void Interpret()
        {
            while(this.Environment.CurrentTokenIndex < this.InputTokens.Count)
            {
                TransformedToken currentToken = this.InputTokens[this.Environment.CurrentTokenIndex];
                switch(currentToken.Type)
                {
                    case TransformedTokenType.CodeBlockOpen:
                        this.Environment.OpenParenthesesStack.Push(currentToken);
                        this.Environment.CurrentTokenIndex++;
                        break;

                    case TransformedTokenType.CodeBlockClose:
                        this.Environment.OpenParenthesesStack.Pop();
                        this.Environment.CurrentTokenIndex++;
                        break;

                    case TransformedTokenType.CallOperator:
                        if(this.Environment.OpenParenthesesStack.Count == 0)
                        {
                            if(this.Operators.ContainsKey(currentToken.Data[0]))
                            {
                                this.Operators[currentToken.Data[0]].Execute(this, this.Environment);
                            }
                            else
                            {
                                Errors.UnknownOperator.Report(
                                    currentToken.Data[0],
                                    currentToken.Position.Line,
                                    currentToken.Position.Column
                                );
                                return;
                            }
                        }
                        this.Environment.CurrentTokenIndex++;
                        break;

                    case TransformedTokenType.CallFunction:
                        if(this.Environment.OpenParenthesesStack.Count == 0)
                        {
                            if(this.Functions.ContainsKey(currentToken.Data[0]))
                            {
                                this.Functions[currentToken.Data[0]].Execute(this, this.Environment);
                            }
                            else
                            {
                                Errors.UnknownFunction.Report(
                                    currentToken.Data[0],
                                    currentToken.Position.Line,
                                    currentToken.Position.Column
                                );
                                return;
                            }
                        }
                        else
                        {
                            this.Environment.CurrentTokenIndex++;
                        }
                        break;

                    case TransformedTokenType.CallCustomFunction:
                        // TODO: Implement:
                        break;

                    default:
                        if(this.Environment.OpenParenthesesStack.Count == 0)
                        {
                            this.Environment.ValueStack.Push(currentToken);
                        }
                        this.Environment.CurrentTokenIndex++;
                        break;
                }
            }
        }
    }
}
